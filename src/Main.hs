{-# LANGUAGE RankNTypes, ExistentialQuantification, FlexibleContexts, TemplateHaskell #-}

module Main where

import qualified Data.Map as M


import Control.Lens hiding (snoc)

import Test.Rufous
import Test.Rufous.Generate
import Test.Rufous.TH
import Test.Rufous.Profile

import Language.Haskell.TH

import Data.Dynamic
import Debug.Trace

p = 
   Profile 
      { _operationWeights=M.fromList [("snoc", 1/2), ("empty", 1/2)]
      , _persistentApplicationWeights=M.fromList [("snoc", 1/2), ("empty", 1/1)]
      , _mortality=1/2
      }

class QueueADT q where
   snoc :: a -> q a -> q a
   empty :: q a

instance QueueADT [] where
   snoc x xs = traceShow ("snoc! evaluate") (xs ++ [x])
   empty     = []

makeRufousSpec ''QueueADT

{-
main :: IO ()
main = do
   print _QueueADT -- generated by TH
   let genState = emptyState _QueueADT p
   putStrLn $ pprintGenState genState
   inflated <- inflate genState
   putStrLn $ pprintGenState inflated
   deflated <- deflate inflated
   putStrLn $ pprintGenState deflated
   print $ deflated
-}

operations = M.fromList [("snoc", toDyn (snoc :: Int -> [Int] -> [Int])), ("empty", toDyn (empty :: [Int]))]

dyns :: [Dynamic]
dyns = [operations M.! "empty"]

data Ty = forall t. Typeable t => Ty { _typ :: t }

versionTy :: Ty
versionTy = Ty (undefined :: [Int])

-- Tries to run `snoc 3 (VERSION 0)`
run :: [Dynamic] -> [Dynamic]
run ds = ds ++ [(operations M.! "snoc") `dynApp` (args !! 0) `dynApp` (args !! 1)]
   where
      args = [toDyn (3 :: Int), ds !! 0]

evalD :: Ty -> Dynamic -> Float
evalD (Ty t) d = (ev t fromDynamic) `seq` 3.0
   where
      ev :: Typeable t => t -> (Dynamic -> Maybe t) -> ()
      ev t f = (f d) `seq` ()

main :: IO ()
main = do
   print $ map (evalD versionTy) $ run dyns
