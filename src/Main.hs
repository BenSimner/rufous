{-# LANGUAGE GADTs, FlexibleInstances, FlexibleContexts, TemplateHaskell #-}

module Main where

import qualified Data.Map as M


import Control.Lens hiding (snoc)

import Test.Rufous
import qualified Test.Rufous.DUG as D
import Test.Rufous.Signature
import Test.Rufous.Generate
import Test.Rufous.TH
import Test.Rufous.Profile
import Test.Rufous.Run
import Test.Rufous.Extract
import Control.Exception
import Test.Rufous.Exceptions

import Language.Haskell.TH

import Data.Dynamic
import Debug.Trace

p = 
   Profile 
      { _operationWeights=M.fromList [("snoc", 1/4), ("empty", 1/4), ("head'", 1/4), ("tail'", 1/4)]
      , _persistentApplicationWeights=M.fromList [("snoc", 1/2), ("empty", 1/1), ("head'", 1/1), ("tail'", 1/1)]
      , _mortality=1/2
      }

class QueueADT q where
   snoc :: a -> q a -> q a
   empty :: q a
   head' :: q a -> a
   tail' :: q a -> q a

instance QueueADT [] where
   snoc x xs = traceShow ("snoc! evaluate") (xs ++ [x])
   empty     = traceShow ("empty! evaluate") ([])
   head' = head
   tail' = tail

instance QueueADT (WrappedADT []) where
   snoc x xs = _log_operation "snoc" [xs] (snoc (x) (getVersion (xs)))
   empty = _log_operation "empty" [] (empty)
   head' xs = _log_observer "head'" [xs] (head' (getVersion (xs)))
   tail' xs = _log_operation "tail'" [xs] (tail' (getVersion (xs)))

-- A Shadow is generally a valid implementation tagged with some 
-- additional information
data Shadow x = Shadow Int

instance QueueADT Shadow where
   snoc x (Shadow q) = Shadow (q + 1)
   empty = Shadow 0

   tail' (Shadow 0) = throw GuardFailed
   tail' (Shadow q) = Shadow (q - 1)

   head' (Shadow 0) = throw GuardFailed
   head' (Shadow q) = throw NotImplemented

makeRufousSpec ''QueueADT

example_program :: QueueADT q => q Int -> IO ()
example_program q = do
   let q' = snoc 1 q
   print $ head' q'
   let q'' = snoc 2 q'
   print $ head' (tail' q'')

main_generate :: IO ()
main_generate = do
   print _QueueADT -- generated by TH
   let genState = emptyState _QueueADT p
   putStrLn $ pprintGenState genState
   inflated <- inflate genState
   putStrLn $ pprintGenState inflated
   deflated <- deflateAll inflated
   putStrLn $ pprintGenState deflated
   print $ deflated
   D.dug2dot (deflated ^. dug) ("tmp")
   tr <- runDUG ((_QueueADT ^. implementations) !! 0) (deflated ^. dug)
   print tr

main_extract :: IO ()
main_extract = do
   init_state
   example_program (empty :: WrappedADT [] Int)
   read_state

main = main_generate
